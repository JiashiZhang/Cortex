import sqlite3
import uuid
import datetime
import os
from typing import List, Dict, Any

import chromadb
from langchain_openai import OpenAIEmbeddings
from langchain_core.tools import tool

# Configuration
DATA_DIR = "./data"
SQLITE_DB_PATH = os.path.join(DATA_DIR, "my_notes.db")
CHROMA_DB_DIR = os.path.join(DATA_DIR, "chromadb")

# Ensure data directory exists
os.makedirs(DATA_DIR, exist_ok=True)

class MemoryStore:
    def __init__(self):
        self._init_sqlite()
        self._init_chroma()

    def _init_sqlite(self):
        """Initialize SQLite database for raw text storage."""
        conn = sqlite3.connect(SQLITE_DB_PATH)
        cursor = conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS notes (
                id TEXT PRIMARY KEY,
                content TEXT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        conn.commit()
        conn.close()

    def _init_chroma(self):
        """Initialize ChromaDB for vector storage."""
        self.chroma_client = chromadb.PersistentClient(path=CHROMA_DB_DIR)
        self.embedding_function = OpenAIEmbeddings(model="text-embedding-3-small")
        
        # Create or get collection
        # Note: ChromaDB's default embedding function might be different, 
        # but we are using LangChain's OpenAIEmbeddings to generate embeddings manually if needed,
        # or we can pass an embedding function to Chroma.
        # For simplicity in this setup, we'll let Chroma handle embeddings if we pass an embedding function,
        # or we generate them. Let's use a simple approach: 
        # We will use the collection to store text and let it handle embeddings if possible, 
        # or generate them before adding.
        
        # However, standard ChromaDB client usage often involves an embedding function.
        # Let's define a wrapper for OpenAIEmbeddings to be compatible with ChromaDB if needed,
        # or just use the raw add/query with embeddings generated by LangChain.
        
        # Actually, for simplicity and better integration with LangChain later if we wanted a Retriever,
        # we might want to use LangChain's Chroma wrapper. But the requirement says "ChromaDB: Local persistence",
        # and "tools/memory_store.py" handles logic.
        
        # Let's stick to the native ChromaDB client for the store logic as requested by the structure,
        # but use OpenAIEmbeddings to generate the vectors.
        
        self.collection = self.chroma_client.get_or_create_collection(
            name="personal_notes"
        )

    def add_note(self, content: str) -> str:
        """Save a note to both SQLite and ChromaDB."""
        note_id = str(uuid.uuid4())
        timestamp = datetime.datetime.now().isoformat()

        # 1. Save to SQLite
        conn = sqlite3.connect(SQLITE_DB_PATH)
        cursor = conn.cursor()
        cursor.execute(
            "INSERT INTO notes (id, content, timestamp) VALUES (?, ?, ?)",
            (note_id, content, timestamp)
        )
        conn.commit()
        conn.close()

        # 2. Save to ChromaDB
        # Generate embedding
        embedding = self.embedding_function.embed_query(content)
        
        self.collection.add(
            ids=[note_id],
            documents=[content],
            embeddings=[embedding],
            metadatas=[{"timestamp": timestamp}]
        )
        
        return f"Note saved successfully with ID: {note_id}"

    def search_notes(self, query: str, n_results: int = 3) -> str:
        """Search notes using semantic search."""
        # Generate embedding for query
        query_embedding = self.embedding_function.embed_query(query)
        
        results = self.collection.query(
            query_embeddings=[query_embedding],
            n_results=n_results
        )
        
        # Format results
        formatted_results = []
        if results['documents']:
            for i, doc in enumerate(results['documents'][0]):
                metadata = results['metadatas'][0][i]
                formatted_results.append(f"[Date: {metadata.get('timestamp', 'N/A')}] {doc}")
        
        if not formatted_results:
            return "No relevant notes found."
            
        return "\n\n".join(formatted_results)

# Initialize the store instance
memory = MemoryStore()

# Define Tools for LangChain Agent

@tool
def save_memory(content: str) -> str:
    """
    Saves a user's thought, note, diary entry, or memo to the long-term memory.
    Use this tool when the user wants to remember something or store information.
    """
    return memory.add_note(content)

@tool
def search_memory(query: str) -> str:
    """
    Searches the long-term memory for relevant notes or information based on a query.
    Use this tool when the user asks about past thoughts, notes, or stored information.
    """
    return memory.search_notes(query)
